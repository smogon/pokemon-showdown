// tools/fusion/generate_fusions.js
const fs = require("fs");
const path = require("path");

const pokedex = JSON.parse(
	fs.readFileSync(path.resolve(__dirname, "pokedex.json")),
);

// simple fusion function (headId, bodyId)
function fuseSpecies(headId, bodyId, newNum) {
	const head = pokedex[headId];
	const body = pokedex[bodyId];
	if (!head || !body) throw new Error("Unknown base species");

	const id = (headId.slice(0, 4) + bodyId.slice(0, 5)).toLowerCase();
	const name =
		head.name.slice(0, Math.min(4, head.name.length)) +
		body.name.slice(0, Math.min(5, body.name.length));

	// Stats: 2/3 body + 1/3 head
	const fuseStats = {};
	for (const k of ["hp", "atk", "def", "spa", "spd", "spe"]) {
		const h =
			(head.baseStats && head.baseStats[k]) || head.baseStat?.[k] || 50;
		const b =
			(body.baseStats && body.baseStats[k]) || body.baseStat?.[k] || 50;
		fuseStats[k] = Math.max(1, Math.round((2 * b + h) / 3));
	}

	// Types: type1 from head, type2 from body (if exists). Fallback to head/body types.
	const headTypes = head.types || (head.type ? [head.type] : []);
	const bodyTypes = body.types || (body.type ? [body.type] : []);
	const types = [headTypes[0] || bodyTypes[0] || "Normal"];
	if (bodyTypes[1] || headTypes[1]) types.push(bodyTypes[1] || headTypes[1]);

	// Abilities: pick head ability 0 if present, else body ability
	const abilities = {};
	if (head.abilities && head.abilities["0"])
		abilities["0"] = head.abilities["0"];
	else if (body.abilities && body.abilities["0"])
		abilities["0"] = body.abilities["0"];
	else abilities["0"] = "RunAway";

	// Minimal fused learnset: union of both movepools (approx)
	let moves = new Set();
	if (head.learnset) Object.keys(head.learnset).forEach((m) => moves.add(m));
	if (body.learnset) Object.keys(body.learnset).forEach((m) => moves.add(m));

	return {
		id,
		entry: {
			num: newNum,
			name,
			baseSpecies: body.name,
			forme: name,
			types,
			baseStats: fuseStats,
			abilities,
			color: body.color || head.color || "Brown",
			eggGroups: body.eggGroups || head.eggGroups || ["Undiscovered"],
		},
		learnset: Array.from(moves),
	};
}

// Example usage: generate three fused species
const pairs = [
	["pikachu", "charizard"],
	["bulbasaur", "blastoise"],
	["gengar", "scizor"],
];

const outPokedex = {};
const outLearnsets = {};
let num = 10001;
for (const [h, b] of pairs) {
	const fused = fuseSpecies(h, b, num++);
	outPokedex[fused.id] = fused.entry;
	outLearnsets[fused.id] = { learnset: {} };
	for (const m of fused.learnset.slice(0, 40))
		outLearnsets[fused.id].learnset[m] = ["9L1"];
}

const pokedexTs = `export const Pokedex: {[k:string]: any} = ${JSON.stringify(
	outPokedex,
	null,
	2,
)};\n`;
const learnsetsTs = `export const Learnsets: {[k:string]: any} = ${JSON.stringify(
	outLearnsets,
	null,
	2,
)};\n`;

fs.mkdirSync(path.resolve(__dirname, "..", "data", "mods", "fusion_gen"), {
	recursive: true,
});
fs.writeFileSync(
	path.resolve(__dirname, "..", "data", "mods", "fusion_gen", "pokedex.ts"),
	"// autogenerated\n" + pokedexTs,
);
fs.writeFileSync(
	path.resolve(__dirname, "..", "data", "mods", "fusion_gen", "learnsets.ts"),
	"// autogenerated\n" + learnsetsTs,
);

console.log("Wrote fused pokedex and learnsets");
